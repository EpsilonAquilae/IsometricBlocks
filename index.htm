
<!doctype html>
<html>
<head>
	<meta charset="utf8">
	<style>
		hr {
			margin-top:3em;
			margin-bottom:3em;
		}
		body {
			width: 800px;
			margin-left:auto;
			margin-right:auto;
			font-size: 1.2em;
		}
		canvas {
			background-color: #EEE;
			border: 0px solid black;
			border-radius: 5px;
			box-shadow: 0px 0px 2px #000;
			margin-right: 5px;
			text-align: center;
		}
		#abstract {
			font-style: italic;
		}
		figure {
			margin-top:2em;
			margin-bottom:2em;
		}
		figcaption {
			font-style: italic;
			color: #555;
		}
		code.block {
			white-space: pre;
			display:block;
			margin-top:3em;
			margin-bottom:3em;
			margin-left: auto;
			margin-right: auto;
			width: 650px;
			padding: 1.5em;
			background: #eee;
			box-shadow: 0px 0px 2px #000;
			border-radius: 5px;
		}
		p.alert{
			border-radius: 5px;
			box-shadow: 0px 0px 2px #000;
			background-color: #ef2929;
			color: white;
			padding: 1em;
		}
		p.alert {
			color: white;
		}

		/* from vim's TOhtml command for syntax highlighting code */
		.lnr { color: #ff0000; }
		.Constant { color: #ef2929; }
		.Statement { color: #3465a4; }
		.Comment { color: #4e9a06; }
		.Identifier { color: #3465a4; }
	</style>

	<script src='src/main.js'></script>
	<script src='src/colors.js'></script>
	<script src='src/block.js'></script>
	<script src='src/camera.js'></script>
	<script src='src/vector.js'></script>
	<script src='src/painter.js'></script>
	<script src='src/sortBlocks.js'></script>
</head>
<body>
<a href="https://github.com/shaunew/IsometricBlocks"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png" alt="Fork me on GitHub"></a>


<a style="text-decoration:none" href="http://www.reddit.com/r/gamedev/comments/18bg95/tutorial_how_to_render_isometric_blocks_correctly/c8dfx51">
	<p class="alert">
Slime0 at reddit identified two errors in this tutorial resulting from (1) possible overlap cycles and (2) incorrect deduction of order between two non-overlapping boxes.  This article will be updated when these issues are resolved.
	</p></a>
	
	<h1>Drawing isometric boxes in the correct order</h1>

	<p>
In an <a href="http://en.wikipedia.org/wiki/Isometric_projection">isometric</a>
display, it can be tricky to draw boxes of various sizes in the correct order
to keep them appropriately in front of or behind one another.  The figure below
shows an example.  The blue box should be drawn first, then green, then red.
	</p>

	<figure>
		<canvas id='figure1a' width=350 height=200></canvas>
		<canvas id='figure1b' width=350 height=200></canvas>
		<figcaption>
Figure 1: The boxes on the left are <u>not</u> drawn in the correct order, whereas the
boxes on the right are drawn correctly.
		</figcaption>
		<script>
			var blocks = [
				new IsoBlock.Block({x:1,y:3,z:0},{x:2,y:2,z:2.5}, IsoBlock.colors.green),
				new IsoBlock.Block({x:2,y:2,z:0},{x:1,y:1,z:1.5}, IsoBlock.colors.red),
				new IsoBlock.Block({x:3,y:1,z:0},{x:1,y:4,z:1},   IsoBlock.colors.blue),
			];
			IsoBlock.makeFigure({ canvas:'figure1a', blocks: blocks, sortBlocks: false, });
			IsoBlock.makeFigure({ canvas:'figure1b', blocks: blocks, });
		</script>
	</figure>

	<p>
We will explore a simple solution for determining the correct order to draw a
given set of boxes.  But first, we must define what we mean by <em>boxes</em>.
	</p>

	<h3>What do we mean by <em>boxes</em>?</h3>

	<p>
We define boxes as <em>axis-aligned</em> and <em>non-intersecting</em>
rectangular prisms. Take a look at the above Figure 1 again.  Each box is
parallel to the <em>x</em>, <em>y</em>, and <em>z</em> axis (i.e.
axis-aligned).  Also, note that the boxes are next to each other but do not
intersect.
	</p>

	<h3>How can we determine when one box is in front of another?</h3>

	<p>
Since our boxes do not intersect each other, we can visualize their separation
as a thin plane between them (see Figure 2 below).  After identifying this
plane, we can determine which box is in front by selecting the one on the
correct side of this plane.
	</p>

	<figure>
		<canvas id='figure2a' width=230 height=200></canvas>
		<canvas id='figure2b' width=230 height=200></canvas>
		<canvas id='figure2c' width=230 height=200></canvas>
		<figcaption>
Figure 2: A pair of blocks can be separated in one of three ways shown here. 
The dark glass illustrates this separation.
		</figcaption>
		<script>
			var refBlock =   new IsoBlock.Block({x:3,y:2,z:0},{x:2,y:2,z:2}, IsoBlock.colors.blue);
			var leftBlock =  new IsoBlock.Block({x:2,y:4,z:0},{x:2.25,y:2,z:1}, IsoBlock.colors.red);
			var topBlock =   new IsoBlock.Block({x:4,y:2,z:2},{x:1.25,y:2,z:1}, IsoBlock.colors.orange);
			var frontBlock = new IsoBlock.Block({x:1,y:1,z:0},{x:2,y:2,z:1}, IsoBlock.colors.green);
			IsoBlock.makeFigure({ canvas:'figure2a', drawPlane: true,
				blocks: [ refBlock, leftBlock ],
			});
			IsoBlock.makeFigure({ canvas:'figure2b', drawPlane: true,
				blocks: [ refBlock, topBlock ],
			});
			IsoBlock.makeFigure({ canvas:'figure2c', drawPlane: true,
				blocks: [ refBlock, frontBlock ],
			});
		</script>
	</figure>

	<p>
We can find this plane of separation by looking at each axis individually.  In
particular, we look for an axis which has non-intersecting box ranges (see
Figure 3 below).  
	</p>

	<figure>
		<canvas id='figure3a' width=350 height=200></canvas>
		<canvas id='figure3b' width=350 height=200></canvas>
		<figcaption>
Figure 3: On the left, the blocks are separated on the y-axis.  On the right,
the blocks are separated on the x-axis. (The z-axis is omitted for simplicity.)
		</figcaption>
		<script>
			IsoBlock.makeFigure({ canvas:'figure3a',
				blocks: [ refBlock, leftBlock ],
				drawAxis: true,
			});
			IsoBlock.makeFigure({ canvas:'figure3b',
				blocks: [ refBlock, frontBlock ],
				drawAxis: true,
			});
		</script>
	</figure>

	<p>
In Figure 3 above, we have chosen a coordinate system which make lesser values
of <em>x</em> and <em>y</em> to be closer to the camera.  Though not shown, the
<em>z</em> axis is positive in the up direction, so a greater value makes it
closer to the camera.
	</p>

	<p>
The following is a javascript function for determining if the first block is in
front of the second:
	</p>

	<code class='block'><span class="Identifier">function</span> isBoxInFront(box1, box2) <span class="Identifier">{</span>

    <span class="Comment">// test for intersection x-axis</span>
    <span class="Comment">// (lower x value is in front)</span>
    <span class="Statement">if</span> (box1.xmin &gt;= box2.xmax) <span class="Identifier">{</span> <span class="Statement">return</span> <span class="Constant">false</span>; <span class="Identifier">}</span>
    <span class="Statement">else</span> <span class="Statement">if</span> (box2.xmin &gt;= box1.xmax) <span class="Identifier">{</span> <span class="Statement">return</span> <span class="Constant">true</span>; <span class="Identifier">}</span>

    <span class="Comment">// test for intersection y-axis</span>
    <span class="Comment">// (lower y value is in front)</span>
    <span class="Statement">if</span> (box1.ymin &gt;= box2.ymax) <span class="Identifier">{</span> <span class="Statement">return</span> <span class="Constant">false</span>; <span class="Identifier">}</span>
    <span class="Statement">else</span> <span class="Statement">if</span> (box2.ymin &gt;= box1.ymax) <span class="Identifier">{</span> <span class="Statement">return</span> <span class="Constant">true</span>; <span class="Identifier">}</span>

    <span class="Comment">// test for intersection z-axis</span>
    <span class="Comment">// (higher z value is in front)</span>
    <span class="Statement">if</span> (box1.zmin &gt;= box2.zmax) <span class="Identifier">{</span> <span class="Statement">return</span> <span class="Constant">true</span>; <span class="Identifier">}</span>
    <span class="Statement">else</span> <span class="Statement">if</span> (box2.zmin &gt;= box1.zmax) <span class="Identifier">{</span> <span class="Statement">return</span> <span class="Constant">false</span>; <span class="Identifier">}</span>

<span class="Identifier">}</span></code>

	<h3>What order do we draw the boxes in?</h3>

	<p>
In general, <u>a box should not be drawn until all the ones behind it are
drawn</u>.  Thus, we begin by drawing the boxes that have nothing behind them.
Then, we can draw the boxes that are only in front of those that are already
drawn. This process continues until all boxes are drawn. (See Figure 4 below
for an example.)
	</p>

	<figure>
		<canvas id='figure4' width=650 height=200></canvas>
		<figcaption>
Figure 4: (1) Nothing is behind blue, so draw it first. (2) Draw green next
since blue was the only one behind it and is already drawn.  (3) Then draw red,
since both blocks that were behind it have been drawn.
		</figcaption>
		<script>
			var blocks = [
				new IsoBlock.Block({x:1,y:3,z:0},{x:2,y:2,z:2.5}, IsoBlock.colors.green),
				new IsoBlock.Block({x:2,y:2,z:0},{x:1,y:1,z:1.5}, IsoBlock.colors.red),
				new IsoBlock.Block({x:3,y:1,z:0},{x:1,y:4,z:1},   IsoBlock.colors.blue),
			];
			IsoBlock.makeFigure({ canvas:'figure4', blocks: blocks, scale: function(w,h) { return h/7; }});
		</script>
	</figure>

	<p>
To implement this algorithm, each box must know exactly which boxes are behind
it.  We have already determined how to do this in the last section.  A search
must be implemented so that each box has a list of boxes behind it.
	</p>

	<p>
You are now armed with everything you need to know to render isometric boxes in
the correct order.
	</p>

	<hr>
	<h2>Appendix</h2>

	
	<h4>A formal description of the solution</h4>

	<p>
For those who are interested, the way in which we determined the drawing order
of the boxes is known in graph theory as a <a
href="http://en.wikipedia.org/wiki/Topological_sorting">topological sort</a>,
which is essentially a depth-first search of a directed graph.
	</p>

	<p>
You can build a directed graph of the <em>boxes</em>, with directed edges to
the boxes that are behind it.  Topologically sorting this graph will produce an
ordered list of boxes that can be drawn in that exact order.
	</p>

	<p>
Mathematicians will recognize this directed graph as a <a
href="http://en.wikipedia.org/wiki/Partially_ordered_set">partially ordered
set</a>.
	</p>

	<h4>Full example of working code</h4>

	<p>
All the diagrams above were created using a simple isometric box renderer
written in Javascript, which applies all the techniques described in this
article.  You can study the fully annotated source code on <a
href="https://github.com/shaunew/IsometricBlocks">IsometricBlocks project on
GitHub</a>.
	</p>

	<h4>Thanks</h4>

	<p>
Thanks to Ted Suzman at <a href="http://playbuildy.com/">buildy</a> for
introducing this problem and solution to me.  And thanks to adamhayek for <a
href="http://www.reddit.com/r/gamedev/comments/18222r/how_to_determine_the_draw_order_for_an_isometric/c8ayzby">further
insight</a> on a general solution. And thanks to <a href="http://www.reddit.com/r/gamedev/comments/18bg95/tutorial_how_to_render_isometric_blocks_correctly/c8dfx51">Slime0 at reddit</a> for pointing out errors resulting in possible overlap cycles and incorrect deduction of order between two non-overlapping boxes.
	</p>

	<hr>

	<figure>
		<canvas id='figure5' width=700 height=200></canvas>
		<script>
			var blocks = [
				new IsoBlock.Block({x:1,y:3,z:0},{x:2,y:2,z:2.5}, IsoBlock.colors.green),
				new IsoBlock.Block({x:2,y:2,z:0},{x:1,y:1,z:1.5}, IsoBlock.colors.red),
				new IsoBlock.Block({x:3,y:1,z:0},{x:1,y:4,z:1},   IsoBlock.colors.blue),
				new IsoBlock.Block({x:0.5,y:5,z:0},{x:2,y:1.5,z:1},   IsoBlock.colors.orange),
				new IsoBlock.Block({x:3,y:3,z:1},{x:1,y:1,z:2.25},   IsoBlock.colors.black),

				// why can't I set this to 1 without all the others disappearing?
				new IsoBlock.Block({x:2,y:7,z:0},{x:1,y:1,z:1},   IsoBlock.colors.white), 

				new IsoBlock.Block({x:5,y:1.5,z:0},{x:2,y:2,z:1.5}, IsoBlock.colors.purple),
			];
			IsoBlock.makeFigure({
				canvas:'figure5',
				blocks: blocks,
				drawAxis:true,
				axisLen: 12,
			});
		</script>
	</figure>

</body>
</html>
